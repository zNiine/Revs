<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Leaderboards - Baseball Analytics</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #fff; font-family: Arial, sans-serif; line-height: 1.4; }
    header, nav { padding: 1rem 2rem; border-bottom: 1px solid #ddd; }
    header { display: flex; justify-content: space-between; align-items: center; }
    #logo { font-size: 1.5rem; font-weight: bold; }
    #search-container { position: relative; }
    #search { padding: 0.5rem; width: 250px; }
    nav#menu ul { list-style: none; display: flex; gap: 2rem; }
    nav#menu a { text-decoration: none; color: #333; font-weight: 500; }
    nav#menu a.active { text-decoration: underline; }
    main { padding: 2rem; }
    .global-filters { margin-bottom: 1rem; }
    .global-filters select { padding: 0.5rem; margin-right: 1rem; }
    .leaderboard { margin-bottom: 3rem; }
    .leaderboard h2 { margin-bottom: 0.5rem; }
    .filters { margin-bottom: 1rem; display: flex; gap: 1rem; }
    .filters input, .filters label { padding: 0.4rem; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 0.5rem; border: 1px solid #ccc; text-align: left; }
.back-to-top {
  margin-left: 1rem;
  padding: 0.2rem 0.5rem;
  font-size: 0.8rem;
  background: #eee;
  border: 1px solid #ccc;
  border-radius: 3px;
  cursor: pointer;
}
.back-to-top:hover {
  background: #ddd;
}
    html {
    scroll-behavior: smooth;
  }
  </style>
</head>
<body>
      <a id="top"></a>

  <header>
    <div id="logo">ALPB</div>
        <form id="search-form">
      <input type="text" id="search" placeholder="Search players, teams, umps..." list="suggestions" autocomplete="off" />
      <button type="submit" id="search-btn">Go</button>
      <datalist id="suggestions"></datalist>
    </form>
    </header>
  <nav id="menu">
    <ul>
      <li><a href="index.html">Home</a></li>
      <li><a href="leaderboards.html" class="active">Leaderboards</a></li>
      <li><a href="#">Search</a></li>
      <li><a href="park-factors.html">Park Factors</a></li>
      <li><a href="#">Point Streak</a></li>
    </ul>
  </nav>

  <nav id="subMenu" style="background:#fafafa;border-bottom:1px solid #ddd;padding:0.5rem 2rem;">
  <ul style="list-style:none;display:flex;gap:1rem;margin:0;padding:0;">
    <li><a href="#hr-distance">Home Run Distance</a></li>
    <li><a href="#ev-speed">Exit Velocity</a></li>
    <li><a href="#chase-rate">Chase Rate</a></li>
    <li><a href="#release-speed">Release Speed</a></li>
    <li><a href="#catcher-stats">Catcher Stats</a></li>
    <li><a href="#avg-ev">Avg Exit Vel</a></li>
    <li><a href="#umpire-accuracy">Umpire Accuracy</a></li>
    <li><a href="#batter-run-exp">Batter RE by Pitch</a></li>
    <li><a href="#pitch-run-exp">Pitcher RE by Pitch</a></li>
  </ul>
</nav>
  <main>
    <div class="global-filters">
      <label for="time-filter">Time Range:</label>
      <select id="time-filter">
        <option value="0" selected>All Time</option>
        <option value="3">Yesterday</option>
        <option value="5">Last 3 Days</option>
        <option value="9" >Last 7 Days</option>
        <option value="17">Last 15 Days</option>
        <option value="30">Last 30 Days</option>
      </select>
    </div>

    <!-- 1. HomeRun Distance -->
    <div class="leaderboard" id="hr-distance">
      <h2>1. HomeRun Distance    <a href="#top" class="back-to-top">Back to Top</a>

</h2>
      <div class="filters">
        <input type="text" id="hr-team-filter" placeholder="Filter by team" list="team-suggestions" />
        <input type="text" id="hr-player-filter" placeholder="Filter by player" list="player-suggestions" />
      </div>
      <table>
        <thead>
          <tr><th>Team</th><th>Batter</th><th>Pitcher</th><th>Exit Vel</th><th>Launch Ang</th><th>Distance</th><th>AutoPitchType</th><th>Date</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- 2. Fastest Exit Velocity -->
    <div class="leaderboard" id="ev-speed">
      <h2>2. Fastest Exit Velocity    <a href="#top" class="back-to-top">Back to Top</a>

</h2>
      <div class="filters">
        <input type="text" id="ev-team-filter" placeholder="Filter by team" list="team-suggestions" />
        <input type="text" id="ev-player-filter" placeholder="Filter by player" list="player-suggestions" />
      </div>
      <table>
        <thead>
          <tr><th>Team</th><th>Batter</th><th>Pitcher</th><th>Exit Vel</th><th>Launch Ang</th><th>PlayResult</th><th>AutoPitchType</th><th>Date</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- 3. Chase Rate -->
    <div class="leaderboard" id="chase-rate">
      <h2>3. Chase Rate   <a href="#top" class="back-to-top">Back to Top</a>

</h2>
      <div class="filters">
        <input type="text" id="chase-team-filter" placeholder="Filter by team" list="team-suggestions" />
        <label for="chase-min-filter">Min Outside Pitches:</label>
        <input type="number" id="chase-min-filter" value="20" min="1" />
      </div>
      <table>
        <thead>
          <tr><th>Player</th><th>Chase Rate</th><th>Total Outside</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- 4. Fastest Release Speed -->
    <div class="leaderboard" id="release-speed">
      <h2>4. Fastest Release Speed    <a href="#top" class="back-to-top">Back to Top</a>

</h2>
      <div class="filters">
        <input type="text" id="rel-team-filter" placeholder="Filter by team" list="team-suggestions" />
      </div>
      <table>
        <thead>
          <tr><th>Pitcher</th><th>Release Speed</th><th>PitchCall</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- 8. Batter Run Expectancy by Pitch Type -->
<div class="leaderboard" id="batter-run-exp">
  <h2>8. Batter Run Expectancy by Pitch Type    <a href="#top" class="back-to-top">Back to Top</a>

</h2>
  <div class="filters">
    <input type="text" id="bre-team-filter"    placeholder="Filter by team"   list="team-suggestions" />
    <input type="text" id="bre-batter-filter" placeholder="Filter by batter" list="player-suggestions" />
  </div>
  <table>
    <thead>
      <tr>
        <th>Batter</th>
        <th>Pitch Type</th>
        <th>Avg Run Value</th>
        <th>Count</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<div class="leaderboard" id="pitch-run-exp">
  <h2>9. Most Effective Pitches (Lowest Avg Run Value)   <a href="#top" class="back-to-top">Back to Top</a>

</h2>
  <div class="filters">
    <input type="text" id="pre-team-filter"    placeholder="Filter by team"   list="team-suggestions" />
    <input type="text" id="pre-pitcher-filter" placeholder="Filter by pitcher" list="player-suggestions" />
  </div>
  <table>
    <thead>
      <tr>
        <th data-key="Pitcher">Pitcher</th>
        <th data-key="Pitch Type">Pitch Type</th>
        <th data-key="AvgRunValue">Avg Run Value</th>
        <th data-key="Count">Count</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

    <div class="leaderboard" id="catcher-stats">
      <h2>5. Average Catcher Stats    <a href="#top" class="back-to-top">Back to Top</a>

</h2>
      <div class="filters">
    <input type="text" id="catcher-player-filter" placeholder="Filter by catcher" list="player-suggestions" />
    <input type="text" id="catcher-team-filter"   placeholder="Filter by team"    list="team-suggestions"  />
  </div>
      <table>
        <thead>
          <tr>
            <th data-key="Catcher">Catcher</th>
            <th data-key="ExchangeTime">Team</th>

            <th data-key="PopTime">Avg PopTime</th>
            <th data-key="ExchangeTime">Avg ExchangeTime</th>
            <th data-key="ThrowSpeed">Avg ThrowSpeed</th>
            <th data-key="Attempts">Attempts</th>

          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

   

    <!-- 6. Average Exit Velocity by Batter -->
    <div class="leaderboard" id="avg-ev">
      <h2>6. Average Exit Velocity by Batter   <a href="#top" class="back-to-top">Back to Top</a>

</h2>
      <div class="filters">
        <input type="text" id="avg-ev-team-filter" placeholder="Filter by team" list="team-suggestions" />
      </div>
      <table>
        <thead>
          <tr><th>Batter</th><th>Team</th><th>Avg Exit Velocity</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>


     <!-- 5. Most Accurate Umpire -->
    <div class="leaderboard" id="umpire-accuracy">
      <h2>7. Most Accurate Umpire   <a href="#top" class="back-to-top">Back to Top</a>

</h2>
      <table>
        <thead>
          <tr><th>Umpire</th><th data-key="Accuracy">Accuracy</th><th>Total Calls</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </main>

  <datalist id="team-suggestions"></datalist>
  <datalist id="player-suggestions"></datalist>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <script>
    const columns = {
      player: 'Batter',
      playerTeam: 'BatterTeam',
      pitcher: 'Pitcher',
      pitcherTeam: 'PitcherTeam',
      playResult: 'PlayResult',
      distance: 'Distance',
      exitSpeed: 'ExitSpeed',
      relSpeed: 'RelSpeed',
      angle: 'Angle',
      ump: 'Umpire',
      autoType: 'AutoPitchType',
      plateHeight: 'PlateLocHeight',
      plateSide: 'PlateLocSide',
      pitchCall: 'PitchCall',
      homeAbbr: 'HomeTeam',
      awayAbbr: 'AwayTeam',
      homeFull: 'HomeNameFull',
      awayFull: 'AwayNameFull',
      date: 'Date'
    };
let fullUmpireRows = [];

    let data = [];
    const teams = new Set(), playersSet = new Set();

    function getFullTeamName(abbr, row) {
      if (abbr === row[columns.homeAbbr]) return row[columns.homeFull];
      if (abbr === row[columns.awayAbbr]) return row[columns.awayFull];
      return abbr;
    }

    function initFilters() {
      teams.forEach(t => document.getElementById('team-suggestions').append(new Option(t)));
      playersSet.forEach(p => document.getElementById('player-suggestions').append(new Option(p)));
    }

    function renderLeaderboard(id, rows, cols) {
  const tbody = document.querySelector(`#${id} tbody`);
  tbody.innerHTML = '';

  rows.forEach(r => {
    const tr = document.createElement('tr');
    cols.forEach(c => {
      const td = document.createElement('td');
      const val = r[c];

      // Decide if this column is a link
      let url = null;
      if (c === 'Batter') {
        url = `batter-profiles.html?player=${encodeURIComponent(val)}`;
      } else if (c === 'Pitcher') {
        url = `pitcher-profiles.html?player=${encodeURIComponent(val)}`;
      } else if (c === 'Umpire') {
        url = `ump-profiles.html?player=${encodeURIComponent(val)}`;
      } else if (c === 'Team') {
        url = `team-profiles.html?team=${encodeURIComponent(val)}`;
      } else if (c === 'Catcher') {
      
                url = `batter-profiles.html?player=${encodeURIComponent(val)}`;

      }

      if (url) {
        const a = document.createElement('a');
        a.href = url;
        a.textContent = val;
        td.appendChild(a);
      } else {
        td.textContent = val;
      }

      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
}

const RV = {
  StrikeCalled:  0.1,
  BallCalled:   -0.1,
  StrikeSwinging: 0.3
  // HomeRuns are handled separately as -0.5 in your code
};

// MLB run expectancy by Ball-Strike count (runs to come)
// Source: aggregate across seasons (0-0 through 3-2)
const RE_COUNT = {
  '0-0': 0.496, '0-1': 0.383, '0-2': 0.254,
  '1-0': 0.621, '1-1': 0.508, '1-2': 0.379,
  '2-0': 0.703, '2-1': 0.590, '2-2': 0.455,
  '3-0': 0.855, '3-1': 0.736, '3-2': 0.602
};

// League‐average RE after a hit/out ends the PA
const RE_AFTER_HIT = {
  Single: 0.757,   // avg RE with runner on 1st, 0 outs
  Double: 1.053,   // runner on 2nd, 0 outs
  Triple: 1.560,   // runner on 3rd, 0 outs
  // for any generic out we'll approximate a single‐out transition
  Out:    0.250    // avg RE after a typical out
};


    function computeAndRender() {
      // time filter
      // pick up how many days the user wants (1 = yesterday-today)
// and compute a cutoff that is midnight-of-(days-1) days ago
const days = +document.getElementById('time-filter').value;
let cutoff = 0;
if (days > 0) {
  // start with today at local midnight:
  const d0 = new Date();
  d0.setHours(0,0,0,0);
  // back up (days - 1) full days
  cutoff = d0.getTime() - (days - 1) * 24 * 3600 * 1000;
}
// now filter
const filtered = data.filter(r =>
  !cutoff || new Date(r[columns.date]).getTime() >= cutoff
);


      // 1. HR Distance
      let hrRows = filtered.filter(r => r[columns.playResult] === 'HomeRun');
      const hrTeam = document.getElementById('hr-team-filter').value;
      const hrPlayer = document.getElementById('hr-player-filter').value;
      if (hrTeam)   hrRows = hrRows.filter(r => getFullTeamName(r[columns.playerTeam],r) === hrTeam);
      if (hrPlayer) hrRows = hrRows.filter(r => r[columns.player] === hrPlayer);
      hrRows.sort((a,b) => parseFloat(b[columns.distance]) - parseFloat(a[columns.distance]));
      const hrDisplay = hrRows.slice(0,10).map(r => ({
        Team: getFullTeamName(r[columns.playerTeam],r),
        Batter: r[columns.player],
        Pitcher: r[columns.pitcher],
        'Exit Vel': r[columns.exitSpeed],
        'Launch Ang': r[columns.angle],
        Distance: r[columns.distance],
        AutoPitchType: r[columns.autoType],
        Date: r[columns.date]
      }));
      renderLeaderboard('hr-distance', hrDisplay, ['Team','Batter','Pitcher','Exit Vel','Launch Ang','Distance','AutoPitchType','Date']);

      // 2. Fastest Exit Velocity
      let evRows = filtered.filter(r =>
        r[columns.exitSpeed] && r[columns.playResult] !== 'Undefined'
      );
      const evTeam = document.getElementById('ev-team-filter').value;
      const evPlayer = document.getElementById('ev-player-filter').value;
      if (evTeam)   evRows = evRows.filter(r => getFullTeamName(r[columns.playerTeam],r) === evTeam);
      if (evPlayer) evRows = evRows.filter(r => r[columns.player] === evPlayer);
      evRows.sort((a,b) => parseFloat(b[columns.exitSpeed]) - parseFloat(a[columns.exitSpeed]));
      const evDisplay = evRows.slice(0,10).map(r => ({
        Team: getFullTeamName(r[columns.playerTeam],r),
        Batter: r[columns.player],
        Pitcher: r[columns.pitcher],
        'Exit Vel': r[columns.exitSpeed],
        'Launch Ang': r[columns.angle],
        PlayResult: r[columns.playResult],
        AutoPitchType: r[columns.autoType],
        Date: r[columns.date]
      }));
      renderLeaderboard('ev-speed', evDisplay, ['Team','Batter','Pitcher','Exit Vel','Launch Ang','PlayResult','AutoPitchType','Date']);

      // 3. Chase Rate
      const chaseMap = {};
      filtered.forEach(r => {
        const h = parseFloat(r[columns.plateHeight]), s = parseFloat(r[columns.plateSide]);
        const outZone = (h < 1.5 || h > 3.5 || s < -0.83 || s > 0.83);
        if (!outZone) return;
        const batter = r[columns.player];
        if (!chaseMap[batter]) chaseMap[batter] = { outside:0, chase:0, team: getFullTeamName(r[columns.playerTeam],r) };
        chaseMap[batter].outside++;
        const call = r[columns.pitchCall];
        if (call !== 'StrikeCalled' && call !== 'BallCalled') chaseMap[batter].chase++;
      });
      let chaseRows = Object.entries(chaseMap).map(([player,stats])=>({
        Player: player,
        ChaseRate: stats.outside ? (stats.chase/stats.outside).toFixed(2) : '0.00',
        TotalOutside: stats.outside,
        Team: stats.team
      }));
      const chaseTeam = document.getElementById('chase-team-filter').value;
      const minOut = +document.getElementById('chase-min-filter').value;
      if (chaseTeam) chaseRows = chaseRows.filter(r => r.Team === chaseTeam);
      chaseRows = chaseRows.filter(r => r.TotalOutside >= minOut);
      chaseRows.sort((a,b) => parseFloat(a.ChaseRate) - parseFloat(b.ChaseRate));
      renderLeaderboard('chase-rate', chaseRows.slice(0,10), ['Player','ChaseRate','TotalOutside']);
// 4. Fastest Release Speed
let relRows = filtered.slice();

// team filter
const relTeam = document.getElementById('rel-team-filter').value;
if (relTeam) {
  relRows = relRows.filter(r =>
    getFullTeamName(r[columns.pitcherTeam], r) === relTeam
  );
}

// only keep rows where RelSpeed parses to a number
relRows = relRows.filter(r => {
  const v = parseFloat(r[columns.relSpeed]);
  return !isNaN(v);
});

// now sort descending
relRows.sort((a,b) =>
  parseFloat(b[columns.relSpeed]) - parseFloat(a[columns.relSpeed])
);

// map out the top 10
const relDisplay = relRows.slice(0,10).map(r => ({
  Pitcher:       r[columns.pitcher],
  'Release Speed': r[columns.relSpeed],
  PitchCall:     r[columns.pitchCall]
}));

renderLeaderboard('release-speed',
  relDisplay,
  ['Pitcher','Release Speed','PitchCall']
);
      
// 7. Catcher Stats
const catcherMap = {};
filtered.forEach(r => {
  // identify the catcher
  const c = r[columns.catcher] || r.Catcher || r.CatcherId;
  if (!c) return;

  // initialize if needed
  if (!catcherMap[c]) {
    const teamName = r[columns.catcherTeam] || r.CatcherTeam || '';
    catcherMap[c] = {
      popSum: 0, popCount: 0,
      exchSum: 0, exchCount: 0,
      throwSum: 0, throwCount: 0,
      team: getFullTeamName(teamName, r)
    };
  }
  const stats = catcherMap[c];

  // Pop Time
  const pop = parseFloat(r[columns.popTime] || r.PopTime || '');
  if (!isNaN(pop) && pop > 0) {
    stats.popSum += pop;
    stats.popCount++;
  }

  // Exchange Time
  const ex = parseFloat(r[columns.exchangeTime] || r.ExchangeTime || '');
  if (!isNaN(ex) && ex > 0) {
    stats.exchSum += ex;
    stats.exchCount++;
  }

  // Throw Speed
  const th = parseFloat(r[columns.throwSpeed] || r.ThrowSpeed || '');
  if (!isNaN(th) && th > 0) {
    stats.throwSum += th;
    stats.throwCount++;
  }
});

let catcherRows = Object.entries(catcherMap).map(([name, s]) => ({
  Catcher:      name,
  Team:         s.team,
  PopTime:      s.popCount   ? (s.popSum   / s.popCount).toFixed(2) : '',
  ExchangeTime: s.exchCount  ? (s.exchSum  / s.exchCount).toFixed(2) : '',
  ThrowSpeed:   s.throwCount ? (s.throwSum / s.throwCount).toFixed(2) : '',
  Attempts:     s.popCount
}));

// apply filters
const cpf = document.getElementById('catcher-player-filter').value;
if (cpf) catcherRows = catcherRows.filter(r => r.Catcher === cpf);
const ctf = document.getElementById('catcher-team-filter').value;
if (ctf) catcherRows = catcherRows.filter(r => catcherMap[r.Catcher].team === ctf);

// league average row
const total = catcherRows.reduce((acc, r) => {
  acc.popSum  += parseFloat(r.PopTime)      || 0;
  acc.exchSum += parseFloat(r.ExchangeTime) || 0;
  acc.throwSum+= parseFloat(r.ThrowSpeed)   || 0;
  acc.count  ++;
  acc.attempts+= r.Attempts;
  return acc;
}, { popSum:0, exchSum:0, throwSum:0, count:0, attempts:0 });

if (total.count > 0) {
  
}

// sort so league average goes last, then by PopTime asc
catcherRows.sort((a, b) =>
  (parseFloat(a.PopTime) || 0) - (parseFloat(b.PopTime) || 0)
);
// render
renderLeaderboard('catcher-stats', catcherRows, [
  'Catcher','Team','PopTime','ExchangeTime','ThrowSpeed','Attempts'
]);

// make headers sortable
document.querySelectorAll('#catcher-stats th[data-key]').forEach(th => {
  th.addEventListener('click', () => {
    const key = th.dataset.key;
    const tbody = document.querySelector('#catcher-stats tbody');
    const rows  = Array.from(tbody.rows);
    const asc   = !th.classList.contains('asc');

    rows.sort((a,b) => {
      const headers = ['Catcher','Team','PopTime','ExchangeTime','ThrowSpeed','Attempts'];
      const idx = headers.indexOf(key);
      let va = key==='Catcher' || key==='Team'
               ? a.cells[idx].innerText
               : parseFloat(a.cells[idx].innerText);
      let vb = key==='Catcher' || key==='Team'
               ? b.cells[idx].innerText
               : parseFloat(b.cells[idx].innerText);
      if (key==='Catcher' || key==='Team') {
        return asc ? va.localeCompare(vb) : vb.localeCompare(va);
      }
      return asc ? va - vb : vb - va;
    });

    tbody.innerHTML = '';
    rows.forEach(r => tbody.appendChild(r));

    document.querySelectorAll('#catcher-stats th').forEach(h => h.classList.remove('asc','desc'));
    th.classList.add(asc ? 'asc' : 'desc');
  });
});



      // 5. Umpire Accuracy
      const umpMap = {};
filtered.forEach(r => {
  const call = r[columns.pitchCall];
  if (call !== 'StrikeCalled' && call !== 'BallCalled') return;
  const u = r[columns.ump];
  if (!umpMap[u]) umpMap[u] = { total:0, correct:0 };
  umpMap[u].total++;
  const h = parseFloat(r[columns.plateHeight]), s = parseFloat(r[columns.plateSide]);
  const inZone = h>=1.5 && h<=3.5 && s>=-0.83 && s<=0.83;
  if ((inZone && call==='StrikeCalled') || (!inZone && call==='BallCalled')) {
    umpMap[u].correct++;
  }
});

// build full array
fullUmpireRows = Object.entries(umpMap).map(([u,stats]) => ({
  Umpire: u,
  Accuracy: stats.total ? +(stats.correct/stats.total).toFixed(2) : 0,
  TotalCalls: stats.total
}));

// initial sort descending
fullUmpireRows.sort((a,b) => b.Accuracy - a.Accuracy);

// render the top 10
renderLeaderboard(
  'umpire-accuracy',
  fullUmpireRows.slice(0,10),
  ['Umpire','Accuracy','TotalCalls']
);
// right after computeAndRender, wire up the sorter:
const thAcc = document.querySelector('#umpire-accuracy th[data-key="Accuracy"]');
if (thAcc) {
  thAcc.style.cursor = 'pointer';
  thAcc.onclick = () => {
    // toggle ascending / descending
    const asc = !thAcc.classList.contains('asc');
    fullUmpireRows.sort((a, b) => asc ? a.Accuracy - b.Accuracy : b.Accuracy - a.Accuracy);
    // re-render top 10
    renderLeaderboard(
      'umpire-accuracy',
      fullUmpireRows.slice(0,10),
      ['Umpire','Accuracy','TotalCalls']
    );
    // update arrow classes
    document.querySelectorAll('#umpire-accuracy th').forEach(h=>h.classList.remove('asc','desc'));
    thAcc.classList.add(asc ? 'asc' : 'desc');
  };
}

      // 6. Average Exit Velocity by Batter
      const avgMap = {};
      filtered
        .filter(r => r[columns.pitchCall] === 'InPlay' && !isNaN(parseFloat(r[columns.exitSpeed])))
        .forEach(r => {
          const bat = r[columns.player];
          const tm  = getFullTeamName(r[columns.playerTeam],r);
          if (!avgMap[bat]) avgMap[bat] = { sum:0, count:0, team: tm };
          avgMap[bat].sum   += parseFloat(r[columns.exitSpeed]);
          avgMap[bat].count += 1;
        });
      let avgRows = Object.entries(avgMap).map(([b,st])=>({
        Batter: b,
        Team: st.team,
        AvgExitVelocity: (st.sum/st.count).toFixed(2)
      }));
      const avgTeam = document.getElementById('avg-ev-team-filter').value;
      if (avgTeam) avgRows = avgRows.filter(r => r.Team === avgTeam);
      avgRows.sort((a,b)=>parseFloat(b.AvgExitVelocity)-parseFloat(a.AvgExitVelocity));
      renderLeaderboard('avg-ev', avgRows.slice(0,10), ['Batter','Team','AvgExitVelocity']);

      drawBatterRunExp(filtered);
      ['bre-team-filter','bre-batter-filter'].forEach(id => {
  document.getElementById(id).addEventListener('input', computeAndRender);
});
drawTruePitchRunExp(filtered);
['pre-team-filter','pre-pitcher-filter'].forEach(id => {
  document.getElementById(id).addEventListener('input', computeAndRender);
});

    }



    Papa.parse('./data.csv', {
      download:true,
      header:true,
      skipEmptyLines:true,
      complete: results => {
        data = results.data;
        data.forEach(r => {
          teams.add(getFullTeamName(r[columns.playerTeam],r));
          teams.add(getFullTeamName(r[columns.pitcherTeam],r));
          playersSet.add(r[columns.player]);
        });

        initSearchHandler();
                    populateSuggestions();
        initFilters();
        [
          'hr-team-filter','hr-player-filter',
          'ev-team-filter','ev-player-filter',
          'chase-team-filter','rel-team-filter',
          'avg-ev-team-filter',
          'chase-min-filter','time-filter','catcher-player-filter','catcher-team-filter'
        ].forEach(id =>
          document.getElementById(id).addEventListener('input', computeAndRender)
        );
        computeAndRender();
        ['bre-team-filter','bre-batter-filter'].forEach(id => {
  document.getElementById(id).addEventListener('input', computeAndRender);
});
      }
    });

function drawBatterRunExp(rows) {
  // 1) Aggregate Batter → Pitch Type
  const brMap = {};

  rows.forEach(r => {
    const pt  = r[columns.autoType];
    const bat = r[columns.player];
    if (!pt) return;  // skip blank pitch types

    const B    = +r.Balls,
          S    = +r.Strikes,
          call = r.PitchCall,
          hit  = r.TaggedHitType,
          runs = parseInt(r.RunsScored, 10) || 0,
          pre  = RE_COUNT[`${B}-${S}`] || 0;

    // determine post‐pitch RE
    let post;
    if (call === 'BallCalled') {
      const key = `${Math.min(B+1,3)}-${S}`;
      post = RE_COUNT[key] || 0;
    } else if (call === 'StrikeCalled' || call === 'StrikeSwinging') {
      const key = `${B}-${Math.min(S+1,2)}`;
      post = RE_COUNT[key] || 0;
    } else if (hit === 'HomeRun') {
      post = 0;
    } else if (RE_AFTER_HIT[hit] != null) {
      post = RE_AFTER_HIT[hit];
    } else {
      post = RE_AFTER_HIT.Out;
    }

    const rv = (pre - post) + runs;
    const team = getFullTeamName(r[columns.playerTeam], r);

    // accumulate
    brMap[bat] = brMap[bat] || {};
    brMap[bat][pt] = brMap[bat][pt] || { sum:0, c:0, team };
    brMap[bat][pt].sum += rv;
    brMap[bat][pt].c   += 1;
  });

  // 2) Flatten to array
  let brRows = [];
  Object.entries(brMap).forEach(([bat, pts]) => {
    Object.entries(pts).forEach(([pt, v]) => {
      brRows.push({
        Batter:        bat,
        'Pitch Type':  pt,
        'Avg Run Value': (v.sum / v.c).toFixed(3),
        Count:         v.c,
        Team:          v.team
      });
    });
  });

  // 3) Filter out blanks and small samples
  brRows = brRows.filter(r => r['Pitch Type'] && r.Count >= 15);

  // 4) Apply UI filters
  const teamF = document.getElementById('bre-team-filter').value;
  const batF  = document.getElementById('bre-batter-filter').value;
  if (teamF) brRows = brRows.filter(r => r.Team === teamF);
  if (batF)  brRows = brRows.filter(r => r.Batter === batF);

  // 5) Sort descending (highest AvgRunValue first)
  brRows.sort((a, b) => parseFloat(b['Avg Run Value']) - parseFloat(a['Avg Run Value']));

  // 6) Render top 20
  renderLeaderboard('batter-run-exp',
    brRows.slice(0,20),
    ['Batter','Pitch Type','Avg Run Value','Count']
  );

  // 7) Make columns sortable
  const tbl = document.getElementById('batter-run-exp');
  tbl.querySelectorAll('th[data-key]').forEach(th => {
    th.style.cursor = 'pointer';
    th.onclick = () => {
      const key = th.dataset.key.replace(/\s+/g, '');
      const asc = !th.classList.contains('asc');
      brRows.sort((a,b) => {
        const va = isNaN(a[key]) ? a[key] : parseFloat(a[key]);
        const vb = isNaN(b[key]) ? b[key] : parseFloat(b[key]);
        return asc ? (va > vb ? 1 : -1) : (va < vb ? 1 : -1);
      });
      renderLeaderboard('batter-run-exp',
        brRows.slice(0,20),
        ['Batter','Pitch Type','Avg Run Value','Count']
      );
      tbl.querySelectorAll('th').forEach(h=>h.classList.remove('asc','desc'));
      th.classList.add(asc?'asc':'desc');
    };
  });
}

    


    function populateSuggestions() {
      const dl = document.getElementById('suggestions');
      const batters = new Set(data.map(r => r.Batter));
      const ump = new Set(data.map(r => r.Umpire));
      const pitchers = new Set(data.map(r => r.Pitcher));
      const teams = new Set(data.map(r => r.HomeNameFull).concat(data.map(r => r.AwayNameFull)));
      [...batters, ...teams, ...pitchers, ...ump].sort().forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        dl.appendChild(opt);
      });
    }

    

function drawTruePitchRunExp(rows) {
  // 1) Aggregate pitcher→pitchType
  const pr = {};
  rows.forEach(r => {
    const pt = r[columns.autoType];
    if (!pt) return;  // skip blank pitch types

    const pit = r[columns.pitcher],
          B   = +r.Balls,
          S   = +r.Strikes,
          call= r[columns.pitchCall],
          hit = r.TaggedHitType,
          runs = parseInt(r.RunsScored, 10) || 0,
          pre  = RE_COUNT[`${B}-${S}`] || 0;

    // determine post‐pitch RE
    let post;
    if (call === 'BallCalled') {
      const key = `${Math.min(B+1,3)}-${S}`;
      post = RE_COUNT[key] || 0;
    } else if (call === 'StrikeCalled' || call === 'StrikeSwinging') {
      const key = `${B}-${Math.min(S+1,2)}`;
      post = RE_COUNT[key] || 0;
    } else if (hit === 'HomeRun') {
      post = 0;
    } else if (RE_AFTER_HIT[hit] != null) {
      post = RE_AFTER_HIT[hit];
    } else {
      // any other in‐play outcome (groundout, flyout, etc.)
      post = RE_AFTER_HIT.Out;
    }

    // run value = RE_before – RE_after + any runs scored
    const rv = (pre - post) + runs;
    const team = getFullTeamName(r[columns.pitcherTeam], r);

    // accumulate
    pr[pit] = pr[pit] || {};
    pr[pit][pt] = pr[pit][pt] || { sum: 0, c: 0, team };
    pr[pit][pt].sum += rv;
    pr[pit][pt].c   += 1;
  });

  // 2) Flatten to array
  let output = [];
  Object.entries(pr).forEach(([pit, pts]) => {
    Object.entries(pts).forEach(([pt, v]) => {
      output.push({
        Pitcher:      pit,
        'Pitch Type': pt,
        AvgRunValue:  (v.sum / v.c).toFixed(3),
        Count:        v.c,
        Team:         v.team
      });
    });
  });

  // 3) Filter out small samples & blanks
  output = output.filter(r => r['Pitch Type'] && r.Count >= 15);

  // 4) Apply UI filters
  const teamF = document.getElementById('pre-team-filter').value;
  const pitF  = document.getElementById('pre-pitcher-filter').value;
  if (teamF) output = output.filter(r => r.Team === teamF);
  if (pitF)  output = output.filter(r => r.Pitcher === pitF);

  // 5) Sort by effectiveness (lowest AvgRunValue first)
  output.sort((a, b) => parseFloat(a.AvgRunValue) - parseFloat(b.AvgRunValue));

  // 6) Render top 20
  renderLeaderboard('pitch-run-exp',
    output.slice(0,20),
    ['Pitcher','Pitch Type','AvgRunValue','Count']
  );

  // 7) Make columns sortable
  const tbl = document.getElementById('pitch-run-exp');
  tbl.querySelectorAll('th[data-key]').forEach(th => {
    th.style.cursor = 'pointer';
    th.onclick = () => {
      const key = th.dataset.key.replace(/\s+/g, '');
      const asc = !th.classList.contains('asc');
      output.sort((a,b) => {
        const va = isNaN(a[key]) ? a[key] : parseFloat(a[key]);
        const vb = isNaN(b[key]) ? b[key] : parseFloat(b[key]);
        return asc ? (va > vb ? 1 : -1) : (va < vb ? 1 : -1);
      });
      renderLeaderboard('pitch-run-exp',
        output.slice(0,20),
        ['Pitcher','Pitch Type','AvgRunValue','Count']
      );
      tbl.querySelectorAll('th').forEach(h=>h.classList.remove('asc','desc'));
      th.classList.add(asc?'asc':'desc');
    };
  });
}
  // filters
  const teamF = document.getElementById('pre-team-filter').value;
  const pitF  = document.getElementById('pre-pitcher-filter').value;
  if (teamF) prRows = prRows.filter(r => r.Team === teamF);
  if (pitF)  prRows = prRows.filter(r => r.Pitcher === pitF);

  // sort ascending for “most effective” (lowest RV first)
  prRows.sort((a,b) => parseFloat(a.AvgRunValue) - parseFloat(b.AvgRunValue));

  // render top 20
  renderLeaderboard('pitch-run-exp',
    prRows.slice(0,20),
    ['Pitcher','Pitch Type','AvgRunValue','Count']
  );

  // make columns sortable by clicking headers
  const tbl = document.getElementById('pitch-run-exp');
  tbl.querySelectorAll('th[data-key]').forEach(th => {
    th.style.cursor = 'pointer';
    th.onclick = () => {
      const key = th.dataset.key.replace(/\s+/g,'');
      const asc = !th.classList.contains('asc');
      prRows.sort((a,b) => {
        const va = key==='Pitcher'||key==='PitchType'
                   ? a[key] : parseFloat(a[key]);
        const vb = key==='Pitcher'||key==='PitchType'
                   ? b[key] : parseFloat(b[key]);
        return asc ? (va>vb?1:-1) : (va<vb?1:-1);
      });
      renderLeaderboard('pitch-run-exp', prRows.slice(0,20),
                        ['Pitcher','Pitch Type','AvgRunValue','Count']);
      tbl.querySelectorAll('th').forEach(h=>h.classList.remove('asc','desc'));
      th.classList.add(asc?'asc':'desc');
    };
  });



    // Attach form submit after data is ready
    function initSearchHandler() {
      document.getElementById('search-form').addEventListener('submit', function(e) {
        e.preventDefault();
        const q = document.getElementById('search').value.trim();

        const isUmp = data.some(r => r.Umpire === q);
        if (isUmp) {
          window.location.href = `ump-profiles.html?player=${encodeURIComponent(q)}`;
          return;
        }

        const isPitcher = data.some(r => r.Pitcher === q);
        if (isPitcher) {
          window.location.href = `pitcher-profiles.html?player=${encodeURIComponent(q)}`;
          return;
        }

        // Check if query matches a batter
        const isBatter = data.some(r => r.Batter === q);
        if (isBatter) {
          window.location.href = `batter-profiles.html?player=${encodeURIComponent(q)}`;
          return;
        }

        // Otherwise check if it matches a team
        const isTeam = data.some(r => r.HomeNameFull === q || r.AwayNameFull === q);
        if (isTeam) {
          window.location.href = `team-profiles.html?team=${encodeURIComponent(q)}`;
          return;
        }

        // Fallback: no match
        alert('No matching player or team found.');
      });
    }

document.querySelectorAll('.back-to-top').forEach(btn => {
  btn.addEventListener('click', () => {
    document.getElementById('top').scrollIntoView({ behavior: 'smooth' });
  });
});

  </script>
</body>
</html>
