<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Pitcher Dashboard</title>
    <link rel="stylesheet" href="style.css" />
    <!-- Libraries -->
    <script src="libs/plotly.min.js"></script>
    <script src="libs/papaparse.min.js"></script>
    <style>
        /* (same styles as batter page) */
        body {
            display: flex;
            flex-direction: column;
            margin: 0;
            font-family: Arial, sans-serif;
        }

        header,
        nav {
            padding: 0.5rem 1rem;
            background: #fafafa;
            border-bottom: 1px solid #ddd;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #logo {
            font-size: 1.5rem;
            font-weight: bold;
        }

        nav#menu ul {
            list-style: none;
            display: flex;
            gap: 1rem;
            margin: 0;
            padding: 0;
        }

        nav#menu a {
            text-decoration: none;
            color: #333;
            font-weight: 500;
        }

        nav#menu a.active {
            text-decoration: underline;
        }

        #subMenu {
            padding: 0.5rem 1rem;
            background: #f0f0f0;
            border-bottom: 1px solid #ddd;
        }

        #subMenu button {
            margin-right: 0.5rem;
            padding: 0.4rem 0.8rem;
        }

        #subMenu .sub-active {
            background: #ddd;
        }

        .container {
            display: flex;
            flex: 1;
        }

        .sidebar {
            width: 250px;
            padding: 1rem;
            background: #f7f7f7;
            border-right: 1px solid #ddd;
        }

        .sidebar .filters {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .sidebar label {
            font-size: 0.9rem;
        }

        .sidebar button {
            margin-top: 1rem;
            padding: 0.5rem;
            cursor: pointer;
        }

        .main {
            flex: 1;
            padding: 1rem;
            overflow: auto;
        }

        #plateContainer {
            display: flex;
            margin-bottom: 2rem;
            height: 400px;
            gap: 0.5rem;
        }

        #plateChart {
            width: 40%;
            height: 100%;
        }

        #legendDiv {
            width: 10%;
            padding-left: 0.5rem;
            font-size: 0.9rem;
        }

        #atBatPitchTable {
            width: 60%;
            overflow: auto;
            font-size: 0.9rem;
            display: none;
            padding-left: 0.5rem;
        }

        #battedBallTable table,
        #atBatPitchTable table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
        }

        #battedBallTable th,
        #battedBallTable td,
        #atBatPitchTable th,
        #atBatPitchTable td {
            border: 1px solid #ccc;
            padding: 0.4rem;
            text-align: left;
        }

        #battedBallTable th,
        #atBatPitchTable th {
            background: #eee;
        }

        @media print {
  header, nav, #subMenu, .sidebar, #paContainer { display: none !important; }
  body, html { margin:0; padding:0; }
  #usageContainer { display:block !important; width:100% !important; }
  .treeWrapper { display:block !important; width:100% !important; }
  #treeChart {
    width:100% !important; height:400px !important;
    page-break-inside: avoid;
  }
  #treeLegend {
    display:block !important;
    width:100% !important;
    margin:1rem 0;
    z-index: 100;
  }
  #validationTable {
    display:block !important;
    width:50% !important;
    max-height: 20vh;       /* keep it from taking too much space */
    margin-top: 210px;
    page-break-before: auto;
        page-break-inside: avoid;

  }
  * { -webkit-print-color-adjust: exact !important; color-adjust: exact !important; }
}
    </style>
</head>

<body>
    <header>
        <div id="logo">ALPB</div>
        <form id="search-form">
      <input type="text" id="search" placeholder="Search players, teams, umps..." list="suggestions" autocomplete="off" />
      <button type="submit" id="search-btn">Go</button>
      <datalist id="suggestions"></datalist>
    </form>
    </header>
    <nav id="menu">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="leaderboards.html">Leaderboards</a></li>
            <li><a href="park-factors.html">Park Factors</a></li>
            <li><a href="#" class="active">Pitcher Profiles</a></li>
        </ul>
    </nav>

    <!-- Sub-menu: toggle between the two profile panels -->
    <div id="subMenu">
        <button id="tabPA" class="sub-active">Plate Appearances</button>
        <button id="tabTree">Usage Tree</button>
        <button id="printTree">Print</button>
        

    </div>

    <div class="container">
        <div class="sidebar">
            <div class="filters">
                <label for="startDate">Start Date</label>
                <input type="date" id="startDate" onchange="applyFilters()" />

                <label for="endDate">End Date</label>
                <input type="date" id="endDate" onchange="applyFilters()" />

                <label>
                    <input type="checkbox" id="showAllDates" onchange="applyFilters()" />
                    Show All Dates
                </label>

                <label for="sideFilter">Batter Side</label>
                <select id="sideFilter" onchange="applyFilters()">
                    <option value="">All</option>
                    <option value="Left">Left</option>
                    <option value="Right">Right</option>
                </select>

                <label for="batterFilter">Batter</label>
                <select id="batterFilter" onchange="onBatterChange()">
                    <option value="">All</option>
                </select>

                <label for="pitchTypeFilter">Pitch Type</label>
                <select id="pitchTypeFilter" onchange="applyFilters()">
                    <option value="">All</option>
                </select>

                <label for="atBatFilter" id="atBatLabel" style="display:none;">At Bat</label>
                <select id="atBatFilter" onchange="applyFilters()" style="display:none;">
                    <option value="">All</option>
                </select>

                <button onclick="resetFilters()">Reset Filters</button>
            </div>
        </div>

        <!-- Plate Appearances view -->
        <div class="main" id="paContainer">
            <h2 id="playerName"></h2>

            <div id="plateContainer">
                <div id="plateChart"></div>
                <div id="legendDiv"></div>
                <div id="atBatPitchTable"></div>
            </div>

            <h3>Spray Chart</h3>
            <div id="sprayChart" style="width:600px;height:600px;margin:auto;"></div>

            <div id="trajectoryChart"></div>

            <h3>Batted Ball Table</h3>
            <div id="battedBallTable"></div>

            <h3>Movement Profile</h3>
<div id="movementContainer" style="text-align:center;">
  <svg id="movementSvg" width="500" height="500" style="border:1px solid #ccc;"></svg>
  <div id="movementLegend" style="text-align:center; margin-top:0.5rem;"></div>

</div>

<h3>Pitch Type Location</h3>
<div style="margin-bottom:0.5rem;">
  <label for="heatmapSideFilter">Batter Side:</label>
  <select id="heatmapSideFilter" onchange="drawLocationHeatmap()">
    <option value="">All</option>
    <option value="Left">Left</option>
    <option value="Right">Right</option>
  </select>

  <label for="locationPitchType" style="margin-left:1rem;">
    Pitch Type:
  </label>
  <select id="locationPitchType" onchange="drawLocationHeatmap()">
    <option value="">All</option>
    <!-- options filled in initDashboard() -->
  </select>
</div>
<div id="locationHeatmap" style="width:500px; height:500px; margin:auto;"></div>

<h3>Pitch Stats By Count</h3>
<div id="pitchStatsByCount"></div>

<h3>Contact Quality Metrics</h3>
<div id="contactMetrics"></div>

<!-- 1. Release Point Scatter -->
<h3>Release Point Profile (Extension vs. Height)</h3>
<div id="releasePointScatter" style="width:600px; height:400px; margin:auto;"></div>

<!-- 2. Spin‐Efficiency Boxplots -->
<h3>Spin vs. Break Boxplots</h3>
<div id="spinBreakBoxplots" style="width:600px; height:400px; margin:auto;"></div>

<!-- 3. Pitch Usage Over Time -->
<h3>Weekly Pitch Mix</h3>
<div id="usageOverTime" style="width:800px; height:400px; margin:auto;"></div>


<!-- 5. Tunneling Map (Ext vs Break) -->
<h3>Tunneling Map</h3>
<div id="tunnelMap" style="display:flex; justify-content:center; gap:1rem;">
  <div id="tunnelX" style="width:300px; height:300px;"></div>
  <div id="tunnelY" style="width:300px; height:300px;"></div>
</div>

<!-- 6. Called‐Swing‐Whiff Table -->
<h3>Pitch Call Rates</h3>
<div id="callRatesTable" style="width:50%; margin:auto;"></div>


<!-- 1) Pitch Sequence Sankey -->
<h3>Pitch Type Transition Sunburst</h3>
<div id="sunburstChart" style="width:700px; height:500px; margin:auto;"></div>

<h3>Zone% by Pitch Type</h3>
<div id="zoneAccuracy" style="width:700px;height:400px;margin:auto;"></div>


<!-- 3) Leverage‐Indexed Run Value -->
<h3>Avg Run Value by Pitch</h3>
<div id="runValueBar" style="width:600px;height:400px;margin:auto;"></div>

<!-- 5) Inning‐by‐Inning Velocity Trend -->
<h3>Avg Release Speed by Inning</h3>
<div id="inningTrend" style="width:700px;height:400px;margin:auto;"></div>




        </div>

        <!-- Usage Tree view -->
        <div class="main" id="usageContainer" style="display:none;">
            <h2 id="playerNameTree"></h2>
            <div style="margin-bottom:1rem;">
                <label for="treeSideFilter">Batter Side:</label>
                <select id="treeSideFilter" onchange="renderUsageTree()">
                    <option value="">All</option>
                    <option value="Left">Left</option>
                    <option value="Right">Right</option>
                </select>
            </div>

            <div class="treeWrapper" style="display:flex; gap:1rem; align-items:flex-start;">
  <!-- Chart -->
  <div id="treeChart" style="width:70%; height:600px; position:relative;"></div>
  <!-- Legend moved out here -->
  <div id="treeLegend" style="width:10%; padding-left:0.5rem; font-size:0.9rem;"></div>
  <!-- Stats table -->
  <div id="validationTable" style="width:20%; height:600px; overflow:auto;
             border:1px solid #ccc; padding:0.5rem; font-size:0.9rem;">
    <strong>Pitch Type Statistics</strong>
    <table style="width:100%; border-collapse: collapse; margin-top:0.5rem;">
      <thead>…</thead>
      <th>Pitch Type</th>
      <th>Count</th>
      <th>Velo Mean</th>
      <th>Std</th>
      <tbody id="statsTableBody"></tbody>
    </table>
  </div>
</div>
        </div>

       
    </div>

    <script>
        let allData = [], playerName = '';
 let data = [];
        document.getElementById('printTree').addEventListener('click', () => {
  // ensure we’re on the Usage Tree first
  document.getElementById('tabTree').click();
  // give the browser a moment to re-layout, then print
  setTimeout(() => window.print(), 200);
});
// use same colors as plate-chart
const PTYPE_COLORS = {};  
(function(){
  // grab the CM mapping from your plate code, e.g.:
  // CM = { "4-Seam": "hsl(0,70%,50%)", ... }
  // or hard-code your palette here:
  PTYPE_COLORS["Four-Seam"] = "#000000";
  PTYPE_COLORS["Sinker"]  = "#FF69B4";
  PTYPE_COLORS["Slider"]  = "#f1c40f";
  PTYPE_COLORS["Curveball"]   = "#FFA500";
  PTYPE_COLORS["Splitter"]   = "#00FFFF";
  PTYPE_COLORS["Cutter"]   = "#800080";
  PTYPE_COLORS["Changeup"]   = "#00FF00";
  PTYPE_COLORS["undefined"]   = "#888888";
  // …add any others you use…
})();


function pnum(v){ const n=parseFloat(v); return isNaN(n)?null:n; }

function drawSunburst(f) {
  // 1) Build transitions
  const trans = {}, byPA = {};
  f.forEach(r => {
    const key = `${r.GameID}|${r.Date}|${r.PAofInning}`;
    byPA[key] = byPA[key] || [];
    byPA[key].push(r);
  });
  Object.values(byPA).forEach(arr => {
    arr.sort((a,b)=> +a.PitchofPA - +b.PitchofPA);
    for (let i=0; i<arr.length-1; i++) {
      const cur = arr[i].AutoPitchType || 'undefined';
      const nxt = arr[i+1].AutoPitchType || 'undefined';
      const k = `${cur}→${nxt}`;
      trans[k] = (trans[k]||0) + 1;
    }
  });

  // 2) Accumulate totals by parent
  const parentTotals = {};
  Object.entries(trans).forEach(([k,v])=>{
    const [cur] = k.split('→');
    parentTotals[cur] = (parentTotals[cur]||0) + v;
  });

  // 3) Build sunburst arrays with unique ids
  const ids = [], labels = [], parents = [], values = [], colors = [];

  // top‐level: each pitch type
  Object.entries(parentTotals).forEach(([pt, sum]) => {
    ids.push(pt);
    labels.push(pt);
    parents.push('');
    values.push(sum);
    colors.push(PTYPE_COLORS[pt] || '#ccc');
  });

  // second‐level: each (pitch→next) transition
  Object.entries(trans).forEach(([k, cnt]) => {
    const [cur, nxt] = k.split('→');
    const nodeId = `${cur}|${nxt}`;  // guaranteed unique
    ids.push(nodeId);
    labels.push(nxt);                // what’s displayed
    parents.push(cur);               // hierarchy link
    values.push(cnt);
    colors.push(PTYPE_COLORS[nxt] || '#ccc');
  });

  // 4) Plot
  Plotly.newPlot('sunburstChart', [{
    type: 'sunburst',
    ids, labels, parents, values,
    marker: { colors },
    branchvalues: 'total',
    hovertemplate:'%{label}<br>Count: %{value}<extra></extra>'
  }], {
    margin: { t:30, l:0, r:0, b:0 }
  });
}

// 1) Pitch Sequence Sankey
function drawSankey(f) {
  // build transitions between consecutive pitches within each PA
  const links = {}, labelsSet = new Set();
  f.sort((a,b)=>a.LocalDateTime.localeCompare(b.LocalDateTime));
  let lastKey = null;
  f.forEach(r => {
    const key = `${r.GameID}-${r.Date}-${r.PAofInning}`;
    const type = r.AutoPitchType || 'undefined';
    if (lastKey === key && lastType) {
      const linkId = `${lastType}->${type}`;
      links[linkId] = (links[linkId]||0) + 1;
    }
    lastKey = key; lastType = type;
    labelsSet.add(type);
  });
  const labels = Array.from(labelsSet);
  const source = [], target = [], value = [];
  Object.entries(links).forEach(([k,v]) => {
    const [s,t] = k.split('->');
    source.push(labels.indexOf(s));
    target.push(labels.indexOf(t));
    value.push(v);
  });

  Plotly.newPlot('sankeyChart',[{
    type: 'sankey',
    orientation:'h',
    node: { label: labels, pad:15, thickness:20, color:labels.map(l=>PTYPE_COLORS[l]||'#ccc') },
    link: { source, target, value }
  }],{ margin:{t:10,l:50,r:50,b:10} });
}

// 2) Zone Usage & Whiff%
function drawZoneHeatmap(f) {
  const xBins = [-0.708, -0.236, 0.236, 0.708],
        yBins = [1.5, 2.166, 2.833, 3.5];
  const usage = [], whiff = [];
  for (let i=0;i<3;i++){
    usage[i]=[]; whiff[i]=[];
    for (let j=0;j<3;j++){
      let tot=0, w=0;
      f.forEach(r=>{
        const x=parseFloat(r.PlateLocSide),
              y=parseFloat(r.PlateLocHeight);
        if (x>=xBins[j] && x<xBins[j+1] && y>=yBins[i] && y<yBins[i+1]){
          tot++;
          if (r.PitchCall==='StrikeSwinging') w++;
        }
      });
      usage[i][j] = tot? tot/f.length*100 : 0;
      whiff[i][j] = tot? w/tot*100 : 0;
    }
  }
  const text = usage.map((row,i)=>
    row.map((u,j)=>`Usage: ${u.toFixed(1)}%<br>Whiff: ${whiff[i][j].toFixed(1)}%`)
  );
  Plotly.newPlot('zoneHeatmap',[{
    z: usage,
    x: ['Low','Middle','High'],    // lateral zones
    y: ['Low','Mid','High'],       // vertical zones
    type:'heatmap',
    colorscale:[[0,'white'],[1,'red']],
    text, hoverinfo:'text'
  }],{
    xaxis:{title:'Horizontal Zone'},
    yaxis:{title:'Vertical Zone', autorange:'reversed'},
    margin:{t:30}
  });
}

// (Make sure RE_COUNT and RE_AFTER_HIT are defined at top of your script, as before)
const RE_COUNT = {
  '0-0': 0.496, '0-1': 0.383, '0-2': 0.254,
  '1-0': 0.621, '1-1': 0.508, '1-2': 0.379,
  '2-0': 0.703, '2-1': 0.590, '2-2': 0.455,
  '3-0': 0.855, '3-1': 0.736, '3-2': 0.602
};

// League‐average RE after a hit/out ends the PA
const RE_AFTER_HIT = {
  Single: 0.757,   // avg RE with runner on 1st, 0 outs
  Double: 1.053,   // runner on 2nd, 0 outs
  Triple: 1.560,   // runner on 3rd, 0 outs
  // for any generic out we'll approximate a single‐out transition
  Out:    0.250    // avg RE after a typical out
};

function drawRunValue(f) {
  // 1) Aggregate by pitch type
  const sums   = {}, 
        counts = {};

  f.forEach(r => {
    const pt   = r.AutoPitchType || 'undefined';
    if (!pt) return;  // skip blanks

    const B    = +r.Balls,
          S    = +r.Strikes,
          call = r.PitchCall,
          hit  = r.TaggedHitType,
          runs = parseInt(r.RunsScored, 10) || 0,
          pre  = RE_COUNT[`${B}-${S}`] || 0;

    // determine post‐pitch RE
    let post;
    if (call === 'BallCalled') {
      const key = `${Math.min(B+1,3)}-${S}`;
      post = RE_COUNT[key] || 0;
    } else if (call === 'StrikeCalled' || call === 'StrikeSwinging') {
      const key = `${B}-${Math.min(S+1,2)}`;
      post = RE_COUNT[key] || 0;
    } else if (hit === 'HomeRun') {
      post = 0;
    } else if (RE_AFTER_HIT[hit] != null) {
      post = RE_AFTER_HIT[hit];
    } else {
      post = RE_AFTER_HIT.Out;
    }

    // run value = (before – after) + any runs scored
    const rv = (pre - post) + runs;

    sums[pt]   = (sums[pt]   || 0) + rv;
    counts[pt] = (counts[pt] || 0) + 1;
  });

  // 2) Compute averages, skip small samples if you like
  const types = Object.keys(sums).sort(),
        avg   = types.map(t => sums[t] / counts[t]);

  // 3) Plot
  Plotly.newPlot('runValueBar', [{
    x: types,
    y: avg,
    type: 'bar',
    marker: { color: types.map(t => PTYPE_COLORS[t] || '#666') },
    hovertemplate: '%{x}<br>Avg RV: %{y:.3f}<br>Count: %{customdata}',
    customdata: types.map(t => counts[t])
  }], {
    yaxis: { title: 'Avg Run Value' },
    margin: { t: 30, l: 50 }
  });
}

// 5) Inning Trend (avg RelSpeed)
function drawInningTrend(f) {
  const byIn = {};
  f.forEach(r=>{
    const inning = r.PAofInning; // or r.Inning
    byIn[inning]=byIn[inning]||{sum:0,c:0};
    const v=parseFloat(r.RelSpeed);
    if(!isNaN(v)){ byIn[inning].sum+=v; byIn[inning].c++; }
  });
  const innings=Object.keys(byIn).map(n=>+n).sort((a,b)=>a-b);
  const avg=innings.map(i=>byIn[i].sum/byIn[i].c);
  Plotly.newPlot('inningTrend',[{
    x:innings, y:avg, mode:'lines+markers', type:'scatter',
    line:{color:'#444'}
  }],{
    xaxis:{title:'PA of Inning'},
    yaxis:{title:'Avg Release Speed (mph)'},
    margin:{t:30,l:50}
  });
}

// 6) Zone Accuracy & Consistency
function drawZoneAccuracy(f) {
  const inZone={}, tot={}, types=new Set();
  f.forEach(r=>{
    const t=r.AutoPitchType;
    types.add(t);
    tot[t]=(tot[t]||0)+1;
    const x=parseFloat(r.PlateLocSide),
          y=parseFloat(r.PlateLocHeight);
    if (x>=-0.708 && x<=0.708 && y>=1.5 && y<=3.5) {
      inZone[t]=(inZone[t]||0)+1;
    }
  });
  const ts=Array.from(types).sort(),
        pct=ts.map(t=> (inZone[t]||0)/tot[t]*100 );
  Plotly.newPlot('zoneAccuracy',[{
    x:ts, y:pct, type:'bar',
    marker:{color:ts.map(t=>PTYPE_COLORS[t]||'#666')}
  }],{
    yaxis:{title:'% In Zone'},
    margin:{t:30,l:50}
  });
}

// 7) Swing‐Decision Timeline
function drawTimeline(f) {
  // map each PA to its series of counts
  const PAs = {};
  f.forEach(r=>{
    const key = `${r.GameID}-${r.Date}-${r.PAofInning}`;
    const idx = parseInt(r.PitchofPA,10);
    PAs[key] = PAs[key]||[];
    PAs[key][idx-1] = +r.Balls + +r.Strikes; // sum for y
  });
  const traces = Object.values(PAs).map(arr=>({
    x: arr.map((_,i)=>i+1),
    y: arr,
    mode:'lines+markers',
    type:'scatter',
    line:{width:1},
    marker:{size:6},
    hoverinfo:'x+y'
  }));
  Plotly.newPlot('timelineChart', traces, {
    xaxis:{title:'# Pitch in PA'},
    yaxis:{title:'Balls+Strikes', dtick:1},
    margin:{t:30,l:50}
  });
}



function drawReleasePoint(f) {
  const ext = f.map(r => parseFloat(r.Extension)),
        rh  = f.map(r => parseFloat(r.RelHeight)),
        c   = f.map(r => r.AutoPitchType);
  const colors = c.map(t => PTYPE_COLORS[t] || "#666");
  
  Plotly.newPlot('releasePointScatter', [{
    x: ext, y: rh,
    mode:'markers',
    type:'scatter',
    marker:{
      size:6,
      color: colors
    },
    text: c,
    hovertemplate:'Ext: %{x:.2f} ft<br>H: %{y:.2f} ft<br>Type: %{text}<extra></extra>'
  }], {
    xaxis:{ title:'Extension (ft)' },
    yaxis:{ title:'Release Height (ft)' },
    margin:{ t:20 }
  });
}

// 2) Spin‐Efficiency Boxplots
function drawSpinBreakBoxes(f) {
  const byType = {};
  f.forEach(r=>{
    const t=r.AutoPitchType;
    if(!byType[t]) byType[t]={spin:[],vert:[]};
    const sp=pnum(r.SpinRate), vb=pnum(r.InducedVertBreak);
    if(sp!=null) byType[t].spin.push(sp);
    if(vb!=null) byType[t].vert.push(vb);
  });
  const types=Object.keys(byType).sort();
  const traces = types.map(t=>({
    y: byType[t].spin,
    name:t,
    type:'box',
    boxmean:'sd'
  }));
  Plotly.newPlot('spinBreakBoxplots', traces, { title:'Spin Rate by Pitch Type', yaxis:{title:'Spin Rate (rpm)'}, margin:{t:30} });
}

// 3) Pitch Usage Over Time
function weekOf(d) {
  const D=new Date(d), oneJan=new Date(D.getFullYear(),0,1);
  return Math.ceil((((D-oneJan)/86400000)+oneJan.getDay()+1)/7);
}

function drawUsageOverTime(f) {
  // aggregate by ISO week
  const byWeek = {};
  f.forEach(r => {
    const w = weekOf(r.Date), t = r.AutoPitchType;
    byWeek[w] = byWeek[w] || { total:0 };
    byWeek[w][t] = (byWeek[w][t]||0) + 1;
    byWeek[w].total++;
  });

  const weeks = Object.keys(byWeek).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
  const types = [...new Set(f.map(r=>r.AutoPitchType))].sort();

  const traces = types.map(t => ({
    x: weeks,
    y: weeks.map(w => byWeek[w][t] ? byWeek[w][t]/byWeek[w].total*100 : 0),
    name: t,
    stackgroup: 'one',
    type: 'scatter'
  }));

  Plotly.newPlot('usageOverTime', traces, {
    xaxis:{ title:'ISO Week', tickmode:'linear', dtick:1 },
    yaxis:{ title:'% of Pitches', ticksuffix:'%', range:[0,100] },
    margin:{ t:30, l:50, b:50 }
  });
}


function drawFastballHeatmap(f) {
  const maxB = 3, maxS = 2;
  // counts[strike][ball]
  const counts = Array(maxS+1).fill().map(() => Array(maxB+1).fill(0));
  const fb     = Array(maxS+1).fill().map(() => Array(maxB+1).fill(0));

  f.forEach(r => {
    const b = parseInt(r.Balls,10),
          s = parseInt(r.Strikes,10);
    if (s <= maxS && b <= maxB) {
      counts[s][b]++;
      if (r.AutoPitchType === 'Four-Seam') fb[s][b]++;
    }
  });

  // build z[strike][ball]
  const z = counts.map((row,s) =>
    row.map((c,b) => c ? fb[s][b] / c * 100 : 0)
  );

  Plotly.newPlot('fastballHeatmap', [{
    z,
    x: [0,1,2],        // strikes
    y: [0,1,2,3],      // balls
    type: 'heatmap',
    colorscale: [[0,'white'],[1,'red']],
    zmin: 0, zmax: 100,
    showscale: true,
    colorbar: { title: '% Four-Seam' }
  }], {
    xaxis: {
      title: 'Balls',
      tickmode: 'array',
      tickvals: [0,1,2],
      ticktext: ['0','1','2', '3']
    },
    yaxis: {
      title: 'Strikes',
      tickmode: 'array',
      tickvals: [0,1,2,3],
      ticktext: ['0','1','2']
    },
    margin: { t: 20, l: 60, b: 60 }
  });
}




function drawTunnelMap(f) {
  // helper to extract and color
  function mkTrace(xArr, yArr, name) {
    const colors = xArr.map((_,i) => PTYPE_COLORS[f[i].AutoPitchType] || "#666");
    return {
      x: xArr,
      y: yArr,
      mode:'markers',
      type:'scatter',
      name,
      marker:{ size:6, color:colors },
      hovertemplate:`Ext: %{x:.2f}<br>${name}: %{y:.2f}<br>Type: %{marker.color}<extra></extra>`
    };
  }

  const ext = f.map(r => parseFloat(r.Extension));
  const hb  = f.map(r => parseFloat(r.HorzBreak));
  const vb  = f.map(r => parseFloat(r.InducedVertBreak));

  Plotly.newPlot('tunnelX', [ mkTrace(ext, hb, 'Horz Break') ], {
    xaxis:{ title:'Extension (ft)' },
    yaxis:{ title:'Horz Break (in)' },
    margin:{ t:20 }
  });
  Plotly.newPlot('tunnelY', [ mkTrace(ext, vb, 'Vert Break') ], {
    xaxis:{ title:'Extension (ft)' },
    yaxis:{ title:'Vert Break (in)' },
    margin:{ t:20 }
  });
}

function renderCallRates(f) {
  const byType = {};
  f.forEach(r => {
    const t = r.AutoPitchType || 'undefined';
    const c = r.PitchCall || 'Undefined';
    if (c === 'Undefined') return;

    byType[t] = byType[t] || { total:0, called:0, swing:0, whiff:0 };
    const d = byType[t];
    d.total++;

    // called strikes
    if (c === 'StrikeCalled') {
      d.called++;
    }

    // swings: swinging strikes, fouls, or balls put in play
    if (c === 'StrikeSwinging' || c.startsWith('Foul') || c === 'InPlay') {
      d.swing++;
      if (c === 'StrikeSwinging') {
        d.whiff++;
      }
    }
  });

  let html = `
    <table style="border-collapse:collapse; width:60%; margin:auto;">
      <thead><tr>
        <th style="border:1px solid #ccc;padding:4px;">Pitch</th>
        <th style="border:1px solid #ccc;padding:4px;">CS%</th>
        <th style="border:1px solid #ccc;padding:4px;">Sw%</th>
        <th style="border:1px solid #ccc;padding:4px;">Wh%</th>
      </tr></thead><tbody>`;

  Object.keys(byType).sort().forEach(t => {
    const d = byType[t];
    const cs = d.total ? (d.called / d.total * 100).toFixed(1) + '%' : '0%';
    const sw = d.total ? (d.swing  / d.total * 100).toFixed(1) + '%' : '0%';
    const wh = d.swing ? (d.whiff  / d.swing * 100).toFixed(1) + '%' : '0%';
    html += `
      <tr>
        <td style="border:1px solid #ccc;padding:4px;">${t}</td>
        <td style="border:1px solid #ccc;padding:4px;text-align:right;">${cs}</td>
        <td style="border:1px solid #ccc;padding:4px;text-align:right;">${sw}</td>
        <td style="border:1px solid #ccc;padding:4px;text-align:right;">${wh}</td>
      </tr>`;
  });

  html += `</tbody></table>`;
  document.getElementById('callRatesTable').innerHTML = html;
}

// 7) Trajectory Animation
function animateTrajectories(f) {
  const canvas = document.getElementById('trajCanvas'),
        ctx = canvas.getContext('2d'),
        toDraw = f.slice(0,5).map(r => {
    // build full coeff arrays
    const Xc = [], Yc = [];
    for (let i=0; i<=8; i++) {
      Xc.push(parseFloat(r['PitchTrajectoryXc'+i])||0);
      Yc.push(parseFloat(r['PitchTrajectoryYc'+i])||0);
    }
    return { Xc, Yc, color:PTYPE_COLORS[r.AutoPitchType]||'#000' };
  });

  let t = 0;
  function frame() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    toDraw.forEach(p => {
      // evaluate polynomial at t ∈ [0,1]
      let x=0, y=0;
      p.Xc.forEach((c,i)=> x += c*Math.pow(t,i));
      p.Yc.forEach((c,i)=> y += c*Math.pow(t,i));
      // scale+translate to canvas
      const cx = x*30 + canvas.width/2;
      const cy = canvas.height - y*30;  
      ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(cx, cy, 4,0,2*Math.PI); ctx.fill();
    });
    t += 0.01;
    if (t <= 1) requestAnimationFrame(frame);
  }
  frame();
}


function computeContactPercentages(data) {
  // 1. Only actual batted-balls
  const contact = data.filter(r => r.PlayResult !== 'Undefined' && r.PitchCall === 'InPlay');
  const total = contact.length;
  if (total === 0) return null;

  // 2. Thresholds
  const TOP_ANG   = 0;   // < 0°
  const UNDER_ANG = 10;  // 0°–10°
  const WEAK_EV   = 85;  // < 85 mph
  const HARD_EV   = 95;  // ≥ 95 mph

  // 3. Bucket counts
  let topped = 0, under = 0, weak = 0, hard = 0;
  contact.forEach(r => {
    const ang = parseFloat(r.Angle),
          ev  = parseFloat(r.ExitSpeed);

    if (!isNaN(ang)) {
      if (ang < TOP_ANG) topped++;
      else if (ang < UNDER_ANG) under++;
    }
    if (!isNaN(ev)) {
      if (ev < WEAK_EV) weak++;
      else if (ev >= HARD_EV) hard++;
    }
  });

  // 4. Percentages
  return {
    ToppedPct:  (topped / total * 100).toFixed(1) + '%',
    UnderPct:   (under  / total * 100).toFixed(1) + '%',
    WeakPct:    (weak   / total * 100).toFixed(1) + '%',
    HardHitPct: (hard   / total * 100).toFixed(1) + '%'
  };
}

// Example usage: call this after filtering your data



function renderPitchStatsByCount(data) {
  // 1) Aggregate as before…
  const stats = {};
  data.forEach(r => {
    const pt = r.AutoPitchType || 'undefined';
    const b = parseInt(r.Balls,10)||0;
    const s = parseInt(r.Strikes,10)||0;
    const key = `${b}-${s}`;
    stats[pt] = stats[pt]||{};
    stats[pt][key] = stats[pt][key]||{ sumV:0, sumS:0, sumH:0, cnt:0 };
    const e = stats[pt][key];
    const v = parseFloat(r.RelSpeed),
          sp = parseFloat(r.SpinRate),
          h = parseFloat(r.RelHeight);
    if (!isNaN(v))  e.sumV += v;
    if (!isNaN(sp)) e.sumS += sp;
    if (!isNaN(h))  e.sumH += h;
    e.cnt += 1;
  });

  // 2) Flatten & sort
  const rows = [];
  Object.keys(stats).sort().forEach(pt => {
    Object.keys(stats[pt]).map(key => {
      const { sumV, sumS, sumH, cnt } = stats[pt][key];
      return {
        count: key,
        pitchType: pt,
        avgV: cnt ? (sumV/cnt).toFixed(1) : '',
        avgS: cnt ? (sumS/cnt).toFixed(0) : '',
        avgH: cnt ? (sumH/cnt).toFixed(2) : ''
      };
    })
    .sort((a,b) => parseInt(a.count.split('-')[0],10) - parseInt(b.count.split('-')[0],10))
    .forEach(r => rows.push(r));
  });

  // 3) Build a bordered table
  let html = `
    <table style="
      border-collapse: collapse;
      width: 100%;
      margin-top: 0.5rem;
    ">
      <thead>
        <tr>
          <th style="border:1px solid #ccc; padding:4px;">Count</th>
          <th style="border:1px solid #ccc; padding:4px;">Pitch Type</th>
          <th style="border:1px solid #ccc; padding:4px; text-align:right;">Release Speed</th>
          <th style="border:1px solid #ccc; padding:4px; text-align:right;">Spin Rate (rpm)</th>
          <th style="border:1px solid #ccc; padding:4px; text-align:right;">Release Height (ft)</th>
        </tr>
      </thead>
      <tbody>
  `;

  rows.forEach(r => {
    html += `
      <tr>
        <td style="border:1px solid #ccc; padding:4px;">${r.count}</td>
        <td style="border:1px solid #ccc; padding:4px;">${r.pitchType}</td>
        <td style="border:1px solid #ccc; padding:4px; text-align:right;">${r.avgV}</td>
        <td style="border:1px solid #ccc; padding:4px; text-align:right;">${r.avgS}</td>
        <td style="border:1px solid #ccc; padding:4px; text-align:right;">${r.avgH}</td>
      </tr>
    `;
  });

  html += `
      </tbody>
    </table>
  `;

  document.getElementById('pitchStatsByCount').innerHTML = html;
}



function drawGrid(svgEl, radius, steps) {
  const ns = "http://www.w3.org/2000/svg";

  // concentric circles + radial tick labels (6", 12", …)
  for (let i = 1; i <= steps; i++) {
    const r = (radius / steps) * i;
    // circle
    const circle = document.createElementNS(ns, "circle");
    circle.setAttribute("cx", radius);
    circle.setAttribute("cy", radius);
    circle.setAttribute("r", r);
    circle.setAttribute("stroke", "#ccc");
    circle.setAttribute("fill", "none");
    svgEl.appendChild(circle);

    // radial label
    const txt = document.createElementNS(ns, "text");
    txt.setAttribute("x", radius + 4);
    txt.setAttribute("y", radius - r + 4);
    txt.setAttribute("font-size", "10");
    txt.setAttribute("fill", "#666");
    txt.textContent = `${6 * i}"`;
    svgEl.appendChild(txt);
  }

  // crosshairs
  [[radius, 0, radius, 2*radius],[0, radius, 2*radius, radius]]
    .forEach(coords => {
      const line = document.createElementNS(ns, "line");
      ["x1","y1","x2","y2"].forEach((att,i)=>line.setAttribute(att, coords[i]));
      line.setAttribute("stroke","#ccc");
      svgEl.appendChild(line);
    });

  // vertical axis label (rotated)
  const yLabel = document.createElementNS(ns, "text");
  yLabel.setAttribute("x", -radius + 20);
  yLabel.setAttribute("y", radius);
  yLabel.setAttribute("transform", `rotate(-90 ${-radius+20},${radius})`);
  yLabel.setAttribute("text-anchor", "middle");
  yLabel.setAttribute("font-size", "12");
  yLabel.setAttribute("fill", "#333");
  yLabel.textContent = "Vert Break (in)";
  svgEl.appendChild(yLabel);

  // horizontal axis tick‐marks & labels
  // we’ll do ticks at -4,-3,-2,-1,0,1,2,3,4 → i*6 inches
  for (let i = -steps; i <= steps; i++) {
    const x = radius + (i / steps) * radius;
    // tick mark
    const tick = document.createElementNS(ns, "line");
    tick.setAttribute("x1", x);
    tick.setAttribute("y1", radius - 4);
    tick.setAttribute("x2", x);
    tick.setAttribute("y2", radius + 4);
    tick.setAttribute("stroke", "#666");
    svgEl.appendChild(tick);
    // label
    const lbl = document.createElementNS(ns, "text");
    lbl.setAttribute("x", x);
    lbl.setAttribute("y", radius + 16);
    lbl.setAttribute("text-anchor", "middle");
    lbl.setAttribute("font-size", "10");
    lbl.setAttribute("fill", "#333");
    lbl.textContent = `${i * 6}"`;
    svgEl.appendChild(lbl);
  }

  // horizontal axis main label
  const xLabel = document.createElementNS(ns, "text");
  xLabel.setAttribute("x", radius);
  xLabel.setAttribute("y", radius * 2 + 30);
  xLabel.setAttribute("text-anchor", "middle");
  xLabel.setAttribute("font-size", "12");
  xLabel.setAttribute("fill", "#333");
  xLabel.textContent = "Horiz Break (in)";
  svgEl.appendChild(xLabel);
}

function drawPoints(svgEl, data, radius, maxBreak) {
  const ns = "http://www.w3.org/2000/svg";
  data.forEach(r => {
    const x = parseFloat(r.HorzBreak),
          y = parseFloat(r.InducedVertBreak);
    if (isNaN(x)||isNaN(y)) return;
    const cx = radius + (x/maxBreak)*radius,
          cy = radius - (y/maxBreak)*radius,
          dot = document.createElementNS(ns,"circle");
    dot.setAttribute("cx", cx);
    dot.setAttribute("cy", cy);
    dot.setAttribute("r", 5);
    dot.setAttribute("fill", PTYPE_COLORS[r.AutoPitchType] || "#666");
    dot.setAttribute("opacity", 0.8);
    svgEl.appendChild(dot);
  });
}

function drawMovementProfile(data) {
  const svg = document.getElementById("movementSvg");
  while (svg.firstChild) svg.removeChild(svg.firstChild);
  const radius = svg.clientWidth / 2;

  drawGrid(svg, radius, 4);
  drawPoints(svg, data, radius, 24);

  // build legend
  const lg = document.getElementById("movementLegend");
  lg.innerHTML = "";  
  Object.entries(PTYPE_COLORS).forEach(([type,color])=>{
    const sw = `<span style="display:inline-block;width:12px;height:12px;background:${color};margin:0 4px 0 12px;"></span>`;
    lg.innerHTML += `${sw}${type}`;
  });
}


        function parseNum(s) { const n = parseFloat(s); return isNaN(n) ? null : n; }
        function onBatterChange() {
            // now a batter was chosen → show atBat dropdown
            const bat = document.getElementById('batterFilter').value;
            const sel = document.getElementById('atBatFilter'),
                lbl = document.getElementById('atBatLabel');
            if (bat) {
                const opts = [...new Set(allData
                    .filter(r => r.Pitcher === playerName && r.Batter === bat)
                    .map(r => `${r.Date.toISOString().slice(0, 10)} PA${r.PAofInning} Inning${r.Inning}`))]
                sel.innerHTML = '<option value=\"\">All</option>' + opts.map(o => `<option>${o}</option>`).join('');
                lbl.style.display = sel.style.display = '';
            } else {
                lbl.style.display = sel.style.display = 'none';
            }
            applyFilters();
        }
        function loadData() {
            Papa.parse('./data.csv', {
                download: true, header: true, skipEmptyLines: true,
                complete: res => {
                            data = res.data;

                    allData = res.data.map(r => ({ ...r, Date: new Date(r.Date) }));
                    initDashboard();
                    initSearchHandler();
                    populateSuggestions();
                }
            });
        }
function drawLocationHeatmap() {
  const typeSel = document.getElementById('locationPitchType').value;
  const sideSel = document.getElementById('heatmapSideFilter').value;

  // filter rows by pitcher, pitch type, and batter side
  const pts = allData.filter(r =>
    r.Pitcher === playerName &&
    (typeSel === '' || r.AutoPitchType === typeSel) &&
    (sideSel === '' || r.BatterSide === sideSel)
  ).map(r => ({
    x: parseFloat(r.PlateLocSide),
    y: parseFloat(r.PlateLocHeight)
  })).filter(p => !isNaN(p.x) && !isNaN(p.y));

  const container = document.getElementById('locationHeatmap');
  if (!pts.length) {
    container.innerHTML = '<em>No data for that selection</em>';
    return;
  }

  const x = pts.map(p => p.x),
        y = pts.map(p => p.y);

  Plotly.newPlot(container, [{
    x, y,
    type: 'histogram2dcontour',
    colorscale: [[0, 'white'], [1, 'red']],
    reversescale: false,
    contours: { coloring: 'heatmap' },
    showscale: true,
    hovertemplate: 'x: %{x:.2f} ft<br>y: %{y:.2f} ft<br>count: %{z}<extra></extra>'
  }], {
    shapes: [
      // strike zone rectangle: from x=-0.708 to +0.708, y=1.5 to 3.5
      {
        type: 'rect',
        x0: -0.708, x1: 0.708,
        y0: 1.5,    y1: 3.5,
        line: { color: 'black', width: 2 },
        fillcolor: 'rgba(0,0,0,0)'  // transparent inside
      }
    ],
    xaxis: {
      title: 'Horizontal Plate Location (ft)',
      range: [-2, 2]
    },
    yaxis: {
      title: 'Vertical Plate Location (ft)',
      range: [0, 5]
    },
    margin: { t: 30, b: 40, l: 40, r: 20 },
    height: 500,
    width: 500
  });
}



        function initDashboard() {
            playerName = new URLSearchParams(location.search).get('player') || '';
 const sample = allData.find(r => r.Pitcher === playerName);
    const handAbbrev = sample
      ? (sample.PitcherThrows === 'Left'  ? 'LHP'
         : sample.PitcherThrows === 'Right' ? 'RHP'
         : '')
      : '';
    // set header to "Lastname, Firstname (RHP)" etc.
    document.getElementById('playerName').textContent =
      handAbbrev
        ? `${playerName} (${handAbbrev})`
        : playerName;
            // populate Batter dropdown
            const batters = [...new Set(allData
                .filter(r => r.Pitcher === playerName)
                .map(r => r.Batter)
            )];
            document.getElementById('batterFilter').innerHTML =
                '<option value="">All</option>' +
                batters.map(b => `<option>${b}</option>`).join('');

            // populate Pitch Type dropdown
            const pts = [...new Set(allData
                .filter(r => r.Pitcher === playerName)
                .map(r => r.AutoPitchType)
            )];
            document.getElementById('pitchTypeFilter').innerHTML =
                '<option value="">All</option>' +
                pts.map(t => `<option>${t}</option>`).join('');

                // fill the new heatmap dropdown
const locSelect = document.getElementById('locationPitchType');
pts.forEach(t => {
  const opt = document.createElement('option');
  opt.value = t;
  opt.textContent = t;
  locSelect.appendChild(opt);
});



            // sub-tab toggles
            document.getElementById('tabPA').addEventListener('click', () => {
                document.getElementById('paContainer').style.display = '';
                document.getElementById('usageContainer').style.display = 'none';
                document.getElementById('tabPA').classList.add('sub-active');
                document.getElementById('tabTree').classList.remove('sub-active');
            });
            document.getElementById('tabTree').addEventListener('click', () => {
                document.getElementById('paContainer').style.display = 'none';
                document.getElementById('usageContainer').style.display = '';
                document.getElementById('tabTree').classList.add('sub-active');
                document.getElementById('tabPA').classList.remove('sub-active');
                document.getElementById('playerNameTree').textContent = handAbbrev
        ? `${playerName} (${handAbbrev})`
        : playerName; + ' — Usage Tree';
                renderUsageTree();
            });

            // disable date inputs when "Show All Dates" checked
            document.getElementById('showAllDates').addEventListener('change', e => {
                const c = e.target.checked;
                document.getElementById('startDate').disabled = c;
                document.getElementById('endDate').disabled = c;
                applyFilters();
            });

            applyFilters();
        }

        function resetFilters() {
            ['startDate', 'endDate'].forEach(id => document.getElementById(id).value = '');
            document.getElementById('showAllDates').checked = false;
            ['sideFilter', 'batterFilter', 'pitchTypeFilter', 'atBatFilter'].forEach(id => {
                document.getElementById(id).value = '';
            });
            document.getElementById('atBatLabel').style.display = 'none';
            document.getElementById('atBatFilter').style.display = 'none';
            applyFilters();
        }
function applyFilters() {
  let f = allData.filter(r => r.Pitcher === playerName);

  // date range
  if (!document.getElementById('showAllDates').checked) {
    const sd = document.getElementById('startDate').value;
    const ed = document.getElementById('endDate').value;
    if (sd) f = f.filter(r => r.Date >= new Date(sd));
    if (ed) f = f.filter(r => r.Date <= new Date(ed));
  }

  // batter side
  const side = document.getElementById('sideFilter').value;
  if (side) f = f.filter(r => r.BatterSide === side);

  // batter filter (just a normal filter now)
  const bat = document.getElementById('batterFilter').value;
  if (bat) f = f.filter(r => r.Batter === bat);

  // pitch type
  const pt = document.getElementById('pitchTypeFilter').value;
  if (pt) f = f.filter(r => r.AutoPitchType === pt);

  // at-bat filter
  const at = document.getElementById('atBatFilter').value;
  if (at) {
    f = f.filter(r =>
      `${r.Date.toISOString().slice(0,10)} PA${r.PAofInning} Inning${r.Inning}` === at
    );
  }

  // now re-render everything
  plotPlate(f);
  plotSpray(f);
  renderTable(f);
  renderAtBatDetails(f);
  drawMovementProfile(f);
  renderPitchStatsByCount(f);

  const metrics = computeContactPercentages(f);
if (metrics) {
  document.getElementById('contactMetrics').innerHTML = `
    <table style="border-collapse:collapse;">
      <tr>
        <th style="border:1px solid #ccc; padding:4px;">Metric</th>
        <th style="border:1px solid #ccc; padding:4px;">%</th>
      </tr>
      <tr>
        <td style="border:1px solid #ccc; padding:4px;">Topped</td>
        <td style="border:1px solid #ccc; padding:4px;">${metrics.ToppedPct}</td>
      </tr>
      <tr>
        <td style="border:1px solid #ccc; padding:4px;">Under</td>
        <td style="border:1px solid #ccc; padding:4px;">${metrics.UnderPct}</td>
      </tr>
      <tr>
        <td style="border:1px solid #ccc; padding:4px;">Weak</td>
        <td style="border:1px solid #ccc; padding:4px;">${metrics.WeakPct}</td>
      </tr>
      <tr>
        <td style="border:1px solid #ccc; padding:4px;">HardHit</td>
        <td style="border:1px solid #ccc; padding:4px;">${metrics.HardHitPct}</td>
      </tr>
    </table>
  `;
} else {
  document.getElementById('contactMetrics').textContent = 'No batted-ball data.';
}


drawReleasePoint(f); drawSpinBreakBoxes(f); drawUsageOverTime(f);
  drawTunnelMap(f); renderCallRates(f);
drawSunburst(f);
  drawRunValue(f);
  drawInningTrend(f);
  drawZoneAccuracy(f);

}

        function onBatterChange() {
  const bat = document.getElementById('batterFilter').value;
  const sel = document.getElementById('atBatFilter'),
        lbl = document.getElementById('atBatLabel');

  if (bat) {
    const opts = [...new Set(
      allData
        .filter(r => r.Pitcher === playerName && r.Batter === bat)
        .map(r => `${r.Date.toISOString().slice(0,10)} PA${r.PAofInning} Inning${r.Inning}`)
    )];
    sel.innerHTML = '<option value="">All</option>' + opts.map(o => `<option>${o}</option>`).join('');
    lbl.style.display = sel.style.display = '';
  } else {
    lbl.style.display = sel.style.display = 'none';
  }

  // now do the normal filtering/rendering
  applyFilters();
}
        function applyBaseFilters(f) {
            const pt = document.getElementById('pitchTypeFilter').value;
            if (pt) f = f.filter(r => r.AutoPitchType === pt);

            const at = document.getElementById('atBatFilter').value;
            if (at) {
                f = f.filter(r =>
                    `${r.Date.toISOString().slice(0, 10)} PA${r.PAofInning} Inning${r.Inning}` === at
                );
            }

            plotPlate(f);
            plotSpray(f);
            renderTable(f);
            renderAtBatDetails(f);
        }


        function plotPlate(data) {
            const atVal = document.getElementById('atBatFilter').value;
            // Build table rows for numbering
            const tableRows = data.filter(r => r.PlayResult !== 'Undefined');
            tableRows.forEach((r, i) => r.__hitNumber = i + 1);
            const indexMap = new Map(tableRows.map(r => [r, r.__hitNumber]));
            // If At Bat selected, number by sequence in 'data'
            const atSeq = atVal ? data.map((_, i) => i + 1) : null;

            const types = [...new Set(data.map(r => r.AutoPitchType))], CM = {};
            types.forEach((t, i) => CM[t] = `hsl(${(i * 60) % 360},70%,50%)`);
            const swing = r => r.PitchCall !== 'StrikeCalled' && r.PitchCall !== 'BallCalled';
            const trace = {
                x: data.map(r => parseNum(r.PlateLocSide)),
                y: data.map(r => parseNum(r.PlateLocHeight)),
                text: data.map((r, i) => atVal ? atSeq[i] : (indexMap.get(r) || '')),
                mode: 'markers+text',
                marker: {
                    symbol: data.map(r => swing(r) ? 'square' : 'circle'),
                    size: 10,
                    color: data.map(r => CM[r.AutoPitchType] || '#999')
                }
            };
            const layout = {
                shapes: [{ type: 'rect', x0: -0.708, x1: 0.708, y0: 1.5, y1: 3.5, line: { color: 'black' } }],
                xaxis: { title: 'Horizontal Location (ft)' },
                yaxis: { title: 'Vertical Location (ft)' },
                height: 400
            };
            Plotly.newPlot('plateChart', [trace], layout);
            let html = '<strong>AutoPitchType:</strong><br>';
            types.forEach(t => html += `<span style="display:inline-block;width:12px;height:12px;background:${CM[t]};margin-right:5px"></span>${t}<br>`);
            html += '<br><strong>Action:</strong><br>';
            html += '<span style="display:inline-block;width:12px;height:12px;background:blue;margin-right:5px"></span>Swing<br>';
            html += '<span style="display:inline-block;width:12px;height:12px;border:1px solid blue;border-radius:50%;margin-right:5px"></span>Take';
            document.getElementById('legendDiv').innerHTML = html;
        }
        function plotSpray(rows) {
            rows = rows.filter(r => r.PlayResult !== 'Undefined');
            const H = 2.0;
            const hits = rows.filter(r => {
                const d = parseNum(r.Direction);
                const dist = parseNum(r.Distance);
                return !isNaN(d) && !isNaN(dist);
            });
            if (!hits.length) { document.getElementById('sprayChart').innerHTML = '<em>No hits</em>'; return; } hits.forEach((r, i) => r.__hitNumber = i + 1);
            const pts = hits.map(r => { const dist = parseNum(r.Distance), dir = parseNum(r.Direction), rad = dir * Math.PI / 180; return { num: r.__hitNumber, x: Math.sin(rad) * dist * H, y: Math.cos(rad) * dist, ev: parseNum(r.ExitSpeed), la: parseNum(r.Angle), type: r.TaggedHitType, distance: dist }; });
            const maxD = Math.max(...pts.map(p => p.distance), 400), F = maxD * 1.05, types2 = [...new Set(pts.map(p => p.type))], C2 = {}; types2.forEach((t, i) => C2[t] = `hsl(${(i * 45) % 360},70%,50%)`);
            const tr2 = { x: pts.map(p => p.x), y: pts.map(p => p.y), mode: 'markers+text', marker: { size: pts.map(p => isNaN(p.ev) ? 10 : Math.min(p.ev / 2, 20)), color: pts.map(p => C2[p.type] || 'gray'), line: { width: 1, color: '#333' }, opacity: 0.8 }, text: pts.map(p => p.num), textposition: 'middle center', hoverinfo: 'text', hovertext: pts.map(p => `#${p.num} ${p.type}<br>EV:${p.ev}<br>LA:${p.la}<br>Dist:${p.distance}`) };
            Plotly.newPlot('sprayChart', [tr2], {
                images: [{
                    source: 'assets/trackman-bg.png',
                    xref: 'x', yref: 'y',
                    x: 0, y: 0,
                    xanchor: 'center', yanchor: 'bottom',
                    sizex: 2 * F,
                    sizey: F * 1.12,
                    sizing: 'stretch',
                    layer: 'below',
                    opacity: 0.8
                }],
                xaxis: {
                    range: [-F, F],
                    zeroline: false,
                    showgrid: false,
                    fixedrange: true,
                    title: 'Left Field ← → Right Field'
                },
                yaxis: {
                    range: [0, F],
                    zeroline: false,
                    showgrid: false,
                    fixedrange: true,
                    scaleanchor: 'x',
                    scaleratio: 1,
                    title: 'Distance from Home Plate (ft)'
                },
                margin: { t: 20, b: 20, l: 20, r: 20 }
            });
        }


        function renderTable(data) { const rows = data.filter(r => r.PlayResult !== 'Undefined'); rows.forEach((r, i) => r.__hitNumber = i + 1); let html = '<table><thead><tr><th>#</th><th>Date</th><th>Batter</th><th>Inning</th><th>PlayCall</th><th>ExitSpeed</th><th>Angle</th><th>Distance</th></tr></thead><tbody>'; rows.forEach(r => { const result = (r.PitchCall === 'InPlay' ? r.PlayResult : r.PitchCall); html += `<tr><td>${r.__hitNumber}</td><td>${r.Date.toISOString().slice(0, 10)}</td><td>${r.Batter}</td><td>${r.Inning}</td><td>${result}</td><td>${r.ExitSpeed}</td><td>${r.Angle}</td><td>${r.Distance}</td></tr>`; }); html += '</tbody></table>'; document.getElementById('battedBallTable').innerHTML = html; }
        function renderAtBatDetails(data) { const at = document.getElementById('atBatFilter').value; const t = document.getElementById('atBatPitchTable'); if (!at) { t.style.display = 'none'; return; } t.style.display = 'block'; let html = '<table><thead><tr><th>#</th><th>Pitch Type</th><th>Result</th><th>RelSpeed</th><th>SpinRate</th><th>InducedVertBreak</th><th>HorzBreak</th><th>Drop</th></tr></thead><tbody>'; data.forEach((r, i) => { const result = (r.PitchCall === 'InPlay' ? r.PlayResult : r.PitchCall); html += `<tr><td>${i + 1}</td><td>${r.AutoPitchType}</td><td>${result}</td><td>${r.RelSpeed || ''}</td><td>${r.SpinRate || ''}</td><td>${r.InducedVertBreak || ''}</td><td>${r.HorzBreak || ''}</td><td>${r.SpeedDrop || ''}</td></tr>`; }); html += '</tbody></table>'; t.innerHTML = html; }

function renderUsageTree() {
  const side = document.getElementById('treeSideFilter').value;
  let rows = allData.filter(r => r.Pitcher === playerName);
  if (side) rows = rows.filter(r => r.BatterSide === side);

  // 1) Build map: "b-s" → count of each AutoPitchType
  const tree = {};
  rows.forEach(r => {
    const key = `${r.Balls}-${r.Strikes}`;
    const type = r.AutoPitchType || 'undefined';
    tree[key] = tree[key] || {};
    tree[key][type] = (tree[key][type]||0) + 1;
  });

  // 2) Determine maximum balls+strikes to know how many rows
  const allKeys = Object.keys(tree).map(ks => ks.split('-').map(Number));
  const maxSum = allKeys.reduce((m, [b,s]) => Math.max(m, b+s), 0);

  const container = document.getElementById('treeChart');
  container.innerHTML = '';

  // Your fixed color palette
  const PALETTE = {
    'Four-Seam': '#000000',
    'Sinker':    '#FF69B4',
    'Slider':    '#0000FF',
    'Changeup':  '#00FF00',
    'Curveball': '#FFA500',
    'Cutter':    '#800080',
    'Splitter':  '#00FFFF',
    'undefined':'#888888'
  };

  // Layout constants
  const boxSize  = 120;
  const spacingX = boxSize + 20;
  const spacingY = boxSize * 0.8 + 10;
  const cW       = container.clientWidth;

  // 3) For each row (sum of balls+strikes) draw all possible counts
  for (let sum = 0; sum <= maxSum; sum++) {
    // build this tier: all (b,s) pairs with b+s = sum
    // build this tier: only valid counts with b ≤ 3 and s ≤ 2, b+s = sum
const tier = [];
for (let b = 0; b <= 3; b++) {
  const s = sum - b;
  if (s < 0 || s > 2) continue;
  const key = `${b}-${s}`;
  tier.push({ b, s, dist: tree[key] || {} });
}

// keep your existing sort by balls descending
tier.sort((a, b) => b.b - a.b);


    // center the tier
    const rowWidth = (tier.length - 1)*spacingX + boxSize;
    const startX   = (cW - rowWidth) / 2;

    tier.forEach((e, i) => {
      // container div for this cell
      const div = document.createElement('div');
      div.style.cssText = `
        position:absolute;
        left:${startX + i*spacingX}px;
        top:${sum*spacingY + (sum>2?15:0)}px;
        width:${boxSize}px;
        height:${boxSize}px;
      `;
      container.appendChild(div);

      // prepare labels/values (or a single zero slice)
      const labels = Object.keys(e.dist).length
        ? Object.keys(e.dist)
        : ['none'];
      const values = Object.keys(e.dist).length
        ? labels.map(l => e.dist[l])
        : [0];

      // draw pie (donut) chart
      Plotly.newPlot(div, [{
        type: 'pie',
        labels,
        values,
        hole: .6,
        marker: { colors: labels.map(l => PALETTE[l] || PALETTE.undefined) },
        textinfo: 'percent',
        textposition: 'inside',
        textfont: { color: '#ffffff' },
        hoverinfo: 'label+value'
      }], {
        margin: { t:0, b:0, l:0, r:0 },
        showlegend: false,
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor:  'rgba(0,0,0,0)'
      });

      // overlay the b-s count and total
      const total = values.reduce((a,v) => a+v, 0);
      const txt = document.createElement('div');
      txt.innerHTML = `${e.b}-${e.s}<br>${total}`;
      txt.style.cssText = `
        position:absolute;
        left:50%; top:50%;
        transform:translate(-50%,-50%);
        text-align:center;
        font-size:14px;
      `;
      div.appendChild(txt);
    });
  }

  // 4) Draw legend
  const legend = document.createElement('div');
  legend.style.cssText = `
    position:absolute;
    left:0; top:0;
    padding:10px;
    background:rgba(255,255,255,0.8);
    font-size:0.9rem;
  `;
  Object.keys(PALETTE).forEach(t => {
    legend.innerHTML += `
      <span style="
        display:inline-block;
        width:12px; height:12px;
        background:${PALETTE[t]};
        margin-right:5px;
        vertical-align:middle;
      "></span>${t}<br>
    `;
  });
  container.appendChild(legend);

  // 5) Build & inject pitch‐type statistics table below (unchanged)
  const stats = {};
  rows.forEach(r => {
    const type = r.AutoPitchType || 'undefined';
    const speed = parseFloat(r.RelSpeed);
    if (isNaN(speed)) return;
    if (!stats[type]) stats[type] = { count:0, sum:0, sumSq:0 };
    stats[type].count++;
    stats[type].sum   += speed;
    stats[type].sumSq += speed*speed;
  });

  const tbody = document.getElementById('statsTableBody');
  let html = '';
  Object.entries(stats)
    .sort(([,a], [,b]) => b.count - a.count)
    .forEach(([type,{count,sum,sumSq}]) => {
      const mean     = sum/count;
      const variance = sumSq/count - mean*mean;
      const std      = Math.sqrt(Math.max(0, variance));
      html += `
        <tr>
          <td>${type}</td>
          <td style="text-align:right">${count}</td>
          <td style="text-align:right">${mean.toFixed(1)}</td>
          <td style="text-align:right">${std.toFixed(1)}</td>
        </tr>`;
    });
  tbody.innerHTML = html;
}

  
function populateSuggestions() {
      const dl = document.getElementById('suggestions');
      const batters = new Set(data.map(r => r.Batter));
      const ump = new Set(data.map(r => r.Umpire));
      const pitchers = new Set(data.map(r => r.Pitcher));
      const teams = new Set(data.map(r => r.HomeNameFull).concat(data.map(r => r.AwayNameFull)));
      [...batters, ...teams, ...pitchers, ...ump].sort().forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        dl.appendChild(opt);
      });
    }

    // Attach form submit after data is ready
    function initSearchHandler() {
      document.getElementById('search-form').addEventListener('submit', function(e) {
        e.preventDefault();
        const q = document.getElementById('search').value.trim();

        const isUmp = data.some(r => r.Umpire === q);
        if (isUmp) {
          window.location.href = `ump-profiles.html?player=${encodeURIComponent(q)}`;
          return;
        }

        const isPitcher = data.some(r => r.Pitcher === q);
        if (isPitcher) {
          window.location.href = `pitcher-profiles.html?player=${encodeURIComponent(q)}`;
          return;
        }

        // Check if query matches a batter
        const isBatter = data.some(r => r.Batter === q);
        if (isBatter) {
          window.location.href = `batter-profiles.html?player=${encodeURIComponent(q)}`;
          return;
        }

        // Otherwise check if it matches a team
        const isTeam = data.some(r => r.HomeNameFull === q || r.AwayNameFull === q);
        if (isTeam) {
          window.location.href = `team-profiles.html?team=${encodeURIComponent(q)}`;
          return;
        }

        // Fallback: no match
        alert('No matching player or team found.');
      });
    }



        window.addEventListener('DOMContentLoaded', loadData);
    </script>
</body>

</html>